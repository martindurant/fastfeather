# automatically generated by the FlatBuffers compiler, do not modify

# namespace: flatbuf

import flatbuffers

# /// Compressed Sparse Fiber (CSF) sparse tensor index.
class SparseTensorIndexCSF(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAsSparseTensorIndexCSF(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SparseTensorIndexCSF()
        x.Init(buf, n + offset)
        return x

    # SparseTensorIndexCSF
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

# /// CSF is a generalization of compressed sparse row (CSR) index.
# /// See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)
# ///
# /// CSF index recursively compresses each dimension of a tensor into a set
# /// of prefix trees. Each path from a root to leaf forms one tensor
# /// non-zero index. CSF is implemented with two arrays of buffers and one
# /// arrays of integers.
# ///
# /// For example, let X be a 2x3x4x5 tensor and let it have the following
# /// 8 non-zero values:
# /// ```text
# ///   X[0, 0, 0, 1] := 1
# ///   X[0, 0, 0, 2] := 2
# ///   X[0, 1, 0, 0] := 3
# ///   X[0, 1, 0, 2] := 4
# ///   X[0, 1, 1, 0] := 5
# ///   X[1, 1, 1, 0] := 6
# ///   X[1, 1, 1, 1] := 7
# ///   X[1, 1, 1, 2] := 8
# /// ```
# /// As a prefix tree this would be represented as:
# /// ```text
# ///         0          1
# ///        / \         |
# ///       0   1        1
# ///      /   / \       |
# ///     0   0   1      1
# ///    /|  /|   |    /| |
# ///   1 2 0 2   0   0 1 2
# /// ```
# /// The type of values in indptrBuffers
    # SparseTensorIndexCSF
    def IndptrType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from .Int import Int
            obj = Int()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

# /// indptrBuffers stores the sparsity structure.
# /// Each two consecutive dimensions in a tensor correspond to a buffer in
# /// indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`
# /// and `indptrBuffers[dim][i + 1]` signify a range of nodes in
# /// `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.
# ///
# /// For example, the indptrBuffers for the above X is:
# /// ```text
# ///   indptrBuffer(X) = [
# ///                       [0, 2, 3],
# ///                       [0, 1, 3, 4],
# ///                       [0, 2, 4, 5, 8]
# ///                     ].
# /// ```
    # SparseTensorIndexCSF
    def IndptrBuffers(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16
            from .Buffer import Buffer
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SparseTensorIndexCSF
    def IndptrBuffersLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

# /// The type of values in indicesBuffers
    # SparseTensorIndexCSF
    def IndicesType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from .Int import Int
            obj = Int()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

# /// indicesBuffers stores values of nodes.
# /// Each tensor dimension corresponds to a buffer in indicesBuffers.
# /// For example, the indicesBuffers for the above X is:
# /// ```text
# ///   indicesBuffer(X) = [
# ///                        [0, 1],
# ///                        [0, 1, 1],
# ///                        [0, 0, 1, 1],
# ///                        [1, 2, 0, 2, 0, 0, 1, 2]
# ///                      ].
# /// ```
    # SparseTensorIndexCSF
    def IndicesBuffers(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16
            from .Buffer import Buffer
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SparseTensorIndexCSF
    def IndicesBuffersLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

# /// axisOrder stores the sequence in which dimensions were traversed to
# /// produce the prefix tree.
# /// For example, the axisOrder for the above X is:
# /// ```text
# ///   axisOrder(X) = [0, 1, 2, 3].
# /// ```
    # SparseTensorIndexCSF
    def AxisOrder(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # SparseTensorIndexCSF
    def AxisOrderAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # SparseTensorIndexCSF
    def AxisOrderLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

def SparseTensorIndexCSFStart(builder): builder.StartObject(5)
def SparseTensorIndexCSFAddIndptrType(builder, indptrType): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(indptrType), 0)
def SparseTensorIndexCSFAddIndptrBuffers(builder, indptrBuffers): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(indptrBuffers), 0)
def SparseTensorIndexCSFStartIndptrBuffersVector(builder, numElems): return builder.StartVector(16, numElems, 8)
def SparseTensorIndexCSFAddIndicesType(builder, indicesType): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(indicesType), 0)
def SparseTensorIndexCSFAddIndicesBuffers(builder, indicesBuffers): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(indicesBuffers), 0)
def SparseTensorIndexCSFStartIndicesBuffersVector(builder, numElems): return builder.StartVector(16, numElems, 8)
def SparseTensorIndexCSFAddAxisOrder(builder, axisOrder): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(axisOrder), 0)
def SparseTensorIndexCSFStartAxisOrderVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def SparseTensorIndexCSFEnd(builder): return builder.EndObject()
